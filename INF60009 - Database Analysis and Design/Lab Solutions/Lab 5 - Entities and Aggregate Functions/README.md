## Lab 5 Notes

### Terms

- **Strong Entity**

A strong entity is an entity that can be defined by its own attribute.

- **Weak Entity**

A weak entity is an entity that cannot be identified by its own attribute and is required to borrow an attribute from another table to be able to identify itself.

- **Primary Key**

A primary key is the attribute in an entity that is used to uniquely identify each row in an entity/table. An entity can have multiple attributes that can be considered as a primary key, but is combined to form a single primary key.

- **Foreign Key**

A foreign key is the attribute in an entity that associates itself to a primary key in another entity.

- **Composite Key**

A composite key is usually a primary key in a table. It is called a composite key as the key is made up of 2 attributes in an entity table that is used to form the single primary key.

- **Count**

Count is a SQL Aggregate Function that is used to do a count of all the rows in the table or a specific column.

- **Sum, Avg**

Are SQL functions that are used to add or find the average of the values in a particular column. Using these functions requires the column names to be defined in the clause.

- **Min, Max**

Are SQL functions that are used to find the minimum and maximum values that are in a particular column. Using these functions requires the column names to be defined in the clause.

- **Group By**

Is an SQL function that allows you to group the result set by a particular column. You can group the result set based on some SQL function calculation against some column in the query table.

- **Having**

Is an SQL function that allows you to filter the result set based on a column that was generated by the SQL function.

### Tutorial Questions

- **Describe the purpose of the MIN aggregate function?**

The Min() aggregate function selects the rows that return the smallest value.

- **How many rows will there be in the result for the following statement**

```
SELECT MIN(BirthYear) from STUDENT
```

There should be 3 rows returned as 1991.

- **Write a single SQL statement that counts the total number of students**

```
SELECT COUNT(*) from STUDENT
```

- **Write a single SQL statement that counts the total number of students that are female**

```
SELECT COUNT(Gender) from STUDENT
WHERE Gender = 'F'
```

- **Write a single SQL statement that counts the total number of students of each gender**

```
SELECT Gender, COUNT(*) from STUDENT
GROUP BY Gender
```

- **Write a single SQL statement that counts the total number of students of each degree**

```
SELECT Degree, COUNT(*) from STUDENT
GROUP BY Degree
```

- **Write a single SQL statement that counts the total number of students in each degree and do not list any result less than 2**

```
SELECT Degree, COUNT(*) from STUDENT
GROUP BY Degree
HAVING COUNT(*) > 2
```

- **Write a single SQL statement that calculates the average number of subjects passed by each degree**

Ignore all males and do not list any values less than 3.

```
SELECT Degree, COUNT(*) from STUDENT
WHERE Gender = 'F'
GROUP BY Degree
HAVING COUNT(*) > 3
```

### Consider the Following ERD

**Insert Image**

- **What is the identifer of the Allocation entity**

There should be 2 identifiers, the first being the EmpNo from the EMPLOYEE table and the TaskNo from the TASK table. This is illustrated by the underlined relationship name of **HAS** and **TO**

- **How many foreign keys will exist in the allocation table**

There should be 2 foreign keys, the EmpNo and the TaskNo.

- **Write the relational schema. Indicate all the primary keys and foreign keys**

EMPLOYEE (EmpNo, EmployeeName)
TASK(TaskNo, Description)

The schema for the Allocation table will borrow the keys from the parents.

ALLOCATION(EmpNo, TaskNo) // **The foreign key of the borrowed keys becomes the primary key, both underlined**

- **Write SQL statements to**

**Create employees Jim Black and Perry White**

```
INSERT INTO EMPLOYEE (EmpNo, EmployeeName) VALUES (1, Jim Black);
INSERT INTO EMPLOYEE (EmpNo, EmployeeName) VALUES (2, Perry White);
```

**Create Tasks Bake Cake and Chop Onions**

```
INSERT INTO TASK (TaskNo, Description) VALUES (1, Bake Cake);
INSERT INTO TASK (TaskNo, Description) VALUES (2, Chop Onions);
```

**Allocate Jim Black to the Chop Onions Tas**

```
INSERT INTO TASK (EmpNo, TaskNo) VALUES (1, 2);
```

**Allocate Perry White to the Bake Cake task**

```
INSERT INTO Task (EmpNo, TaskNo) VALUES (2, 1);
```

### Consider the following business case and diagram

**Insert Image**

**What is the identifier of each entity**

SUBURB - Suburb Name

HOUSE - HouseNo, StreetName, SuburbName and BuilderCode (Maybe just HouseNo, SuburbName and BuilderCode underline then all)

BUILDER - BuilderCode

**Convert to a relational schema**

SUBURB(Suburb, Population) // Where Suburb is underlined to represent the primary key
HOUSE (Suburb, BuilderCode, HouseNo, StreetName, DateBuilt) // Where SuburbName, BuilderCode are borrowed primary keys for the HOUSE entity.
BUILDEr (BuilderCode, BuilderName) // Where BuilderCode is underlined to represent the primary key.

- **Consider the following SQL statement**

```
CREATE TABLE ROOM (
	BuilderCode varchar(10),
	OfficeNo number,
	PhoneNo varchar(10),
	OfficeSize number NOT NULL,
	Primary Key (BuildingCode, OfficeNo)
);
```

**Does this statement have any column constraints?**

This statement will have 1 column constraint. The column constraint is the OfficeSize.

This is defined as a column constraint as it is written next to the column definition.

**Does this statement have any table constraints**

This statement will have 2 table constraints. The BuildingCode and the OfficeNo. The reason that these are table constraints is because they are listed under the Primary Key (BuildingCode, OfficeNo) towards the bottom of the table. This means the two columns are constrained as they make up the composite key for the table.

### Lab Questions

- **List the Movie number, movie title, colour name and the long rating description of every movie**

```
SELECT M.MOVIENO, M.TITLE, C.COLOUR_NAME, R.LONGDESC
FROM MOVIE M
INNER JOIN MOVIECOLOUR C
ON M.COLOUR_CODE = C.COLOUR_CODE
INNER JOIN RATING R
ON M.RATING_CODE = R.RATING_CODE
ORDER BY MOVIENO ASC;
```

- **Same as above but only for movies made in this period 2003 to 2008**

```
SELECT M.MOVIENO, M.TITLE, C.COLOUR_NAME, R.LONGDESC, M.RELYEAR
FROM MOVIE M
INNER JOIN MOVIECOLOUR C
ON M.COLOUR_CODE = C.COLOUR_CODE
INNER JOIN RATING R
ON M.RATING_CODE = R.RATING_CODE
WHERE RELYEAR >= 2003 AND RELYEAR <= 2008
ORDER BY RELYEAR ASC;

OR

SELECT M.MOVIENO, M.TITLE, C.COLOUR_NAME, R.LONGDESC, M.RELYEAR
FROM MOVIE M
INNER JOIN MOVIECOLOUR C
ON M.COLOUR_CODE = C.COLOUR_CODE
INNER JOIN RATING R
ON M.RATING_CODE = R.RATING_CODE
WHERE RELYEAR BETWEEN 2003 AND 2008
ORDER BY RELYEAR ASC;
```

- **Using the Count() function, display the number of movies made in 2005**

```
SELECT COUNT(*) FROM MOVIE
WHERE RELYEAR = 2005;
```

- **Using the Count() function, display the number of movies made within the years 2010 - 2015**

```
SELECT COUNT(RELYEAR) FROM MOVIE
WHERE RELYEAR BETWEEN 2010 AND 2015

OR

SELECT COUNT(*) FROM MOVIE
WHERE RELYEAR >= 2010 
AND RELYEAR <= 2015

OR

SELECT RELYEAR, COUNT(*)
FROM MOVIE
WHERE RELYEAR BETWEEN 2010 AND 2015
GROUP BY RELYEAR
ORDER BY RELYEAR
```

- **Using the Count() function, list the movies with a PG rating code**

```
SELECT COUNT(*) FROM MOVIE
WHERE RATING_CODE = 'PG'; 
```

### Aggregate Expression and Group By Questions

- **Using the Count() function and the Group By clause, list the number of movies of each rating code**

```
SELECT RATING_CODE, COUNT(*) FROM MOVIE
GROUP BY RATING_CODE
```

- **Same as above but the list must appear in descending count sequence**

```
SELECT RATING_CODE, COUNT(*) FROM MOVIE
GROUP BY RATING_CODE
ORDER BY 2 DESC;
```

- **Same as above but change the headings of both columns as shown (Movie Rating Code, Total)

```
SELECT RATING_CODE AS "Movie Rating Code", COUNT(*) AS "Total"
FROM MOVIE
GROUP BY RATING_CODE
ORDER BY "Total" DESC;
```

- **Using the Count() function and the Group By clause, list maximum IMDB_SCORE for each release year in the movie table. List must be in ascending year sequence**

```
SELECT RELYEAR, MAX(IMDB_SCORE)
FROM MOVIE
GROUP BY RELYEAR
ORDER BY RELYEAR ASC;
```

### ACTOR TABLE

- **List all columns from the Actor table only born in the USA**

```
SELECT * FROM ACTOR
WHERE BORNIN = 'USA'
```

- **Using the Count() function, list the number of actors born in the USA**

```
SELECT COUNT(*) FROM ACTOR
WHERE BORNIN = 'USA'
```

- **Using the Count() function, list the number of actors born in Australia**

```
SELECT COUNT(*) FROM ACTOR
WHERE UPPER(BORNIN) = 'AUSTRALIA'
```

- **Using the Count() function, list the number of actors whose bornin value IS NULL**

```
SELECT COUNT(*) FROM ACTOR
WHERE BORNIN IS NULL
```

- **Using the Count() function, list the number of actors whose birthdate value IS NULL**

```
SELECT COUNT(*) FROM ACTOR
WHERE BIRTHDATE IS NULL
```

- **Using the Count() function and the Group By clause, list the number of actors for each bornin value**

```
SELECT BORNIN, COUNT(*) FROM ACTOR
GROUP BY BORNIN
```

- **Same as above but order the result in descending count values**

```
SELECT BORNIN, COUNT(*) FROM ACTOR
GROUP BY BORNIN
ORDER BY 2 DESC;
```

- **Using the Count() and Group By clause, list the number of actors of each gender that were born in each country**

```
SELECT BORNIN, GENDER, COUNT(*) FROM ACTOR
GROUP BY BORNIN, GENDER
ORDER BY BORNIN ASC;
```

### Group By Having Questions

- **Using the Having clause, show the count value less than 2 for the previous query**

```
SELECT BORNIN, GENDER, COUNT(*) FROM ACTOR
GROUP BY BORNIN, GENDER
HAVING COUNT(*) < 2
ORDER BY BORNIN ASC
```

- **Using the Group Clause show the count of the number of movies made in each year. The list must be in ascending count sequence**

```
SELECT RELYEAR, COUNT(*) FROM MOVIE
GROUP BY RELYEARASC
```

### Casting Table

- **Write the SQL statements to list the rows from CASTING in MovieNo order**

```
SELECT * FROM CASTING
ORDER BY MovieNo
```

- **What is the Primary Key of Movie**

MOVIENO is the primary key of Movie

- **What is the Primary Key of Actor**

ACTORNO is the primary key of Actor

- **What is the Foreign Key of Casting**

The Foreign Keys are MOVIENO from the MOVIE table and the ACTORNO from the ACTOR table. Incidentally these are both primary keys of the CASTING table.

- **Using an Inner Join, modify the SQL statement above to display movie title, movie number and actor number from the CASTING and MOVIE tables**

```
SELECT M.MOVIENO, M.TITLE, ACTORNO
FROM CASTING C
INNER JOIN MOVIE M
ON M.MOVIENO = C.MOVIENO
ORDER BY C.MOVIENO
```

- **Using 2 Inner Joins, modify the SQL statement above so each actors full name is displayed**

```
SELECT M.MOVIENO, M.TITLE, A.ACTORNO, A.FULLNAME
FROM CASTING C
INNER JOIN MOVIE M
ON M.MOVIENO = C.MOVIENO
INNER JOIN ACTOR A
ON C.ACTORNO = A.ACTORNO
ORDER BY C.MOVIENO
```

- **Same as the above but only display rows if the actors fullname is Bill Murray**

```
SELECT M.MOVIENO, M.TITLE, A.ACTORNO, A.FULLNAME
FROM CASTING C
INNER JOIN MOVIE M
ON M.MOVIENO = C.MOVIENO
INNER JOIN ACTOR A
ON C.ACTORNO = A.ACTORNO
WHERE A.FULLNAME = 'Bill Murray'
ORDER BY C.MOVIENO
```

### Adding Data to Movie, Actor and Casting Tables

- **Insert Bill Murray into the Ghost Busters Movie**

If we are entering a new link between the actor and movie tables, given that the entry still exists, we only need to add it into the casting table.

In other words, because the movie Ghostbusters exists in the Movie table and the actor Bill Murray exists in the actor table, we only need to add the entry into the casting table.

```
INSERT INTO CASTING (MOVIENO,ACTORNO) VALUES (620, 1532);
```


